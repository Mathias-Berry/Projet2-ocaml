Bonjour, on a décidé d'inverser les roles pour ce rendu. Donc Mathias a fait le parser/lexer et Emile a fait la partie eval et les tests.

Pour la partie lexer, il n'y a pas grand chose a dire. Pour le parser, il n'y a pas grand chose a dire sur l'ajout de := ! ; ref ou () si ce n'est de faire attention pour les priorités. Nous avons changé le type de prInt et on lui donné un type a lui même pour qu'il ếtre appélé par d'autre fonctions en fouine. Ensuite, pour l'ajout des tuples Mathias créer une nouvelle catégorie les tuples qui sont soit tuples ; une expression ou soit jsute une expression ; une expression.
Ajouter les tuples nous a fait changer notre type pouur le let ... in. Nous pouvons désormais faire des chose du genre let a,b = ... in. On a donc du créer un nouveau type nommé motif qui peut contenir des varibles, des liste ou des tuples.
Pour ajouter les liste, Mathias a fait utiliser la méthode de lire un "[" puis les éléments de la liste et enfin un "]". Il n'y a pas grand chose a dire sur Cons. ( commentaire d'Emile avec lequel mathias est d'accord : mais donc cette méthode ne permet pas de faire d'évaluer une fonction en une liste sans utiliser de parenthèses ).
Ensuite pour ajouter les matching, nous avons enrichi notre type motif avec les entiers et on voit le matching comme un couple contenant une expression et une liste de motif*expression conenant le motif lu avec la réponse qu'il faut renvoyer en cas. Mathias a fait deux règle pour rentre dans le match permettant de rendre optionnel le premier |.
Ensuite pour les expressions sahcant qu'il n'existe que l'exception E. On a ajouter ajoute uniquement les type raise et try ... with à expr. On voit try with comme un match (dans le cotés parser). Il n'y a rien a dire sur raise.

Emile s'est occupé surtout de la partie eval, et un peu de la partie parser, en apportant quelques modifications an plus quand ca l'arrangeai ( le try était au début du type expr*( (expr*expr) list) où j'ai changé un expr en motif ou encore le fait que avant dans motif on avait pas STR on avait que des string listes de manière à parser d'un seul coup les fonctions de type let f x y = ... ).
Ensuite, en ce qui concerne tous jusqu'au exception, on en a parlé en cours ( emile a simplement rajouter pour eviter que a,_puisse être matcher avec 1,2,3, le fait qu'on regarde la taille des tuples qu'on considère à chaque fois ). Après pour les excedptions, à chaque fois que j'évalue un élement pour en refaire quelque chose, je regarde si c'est une exception, si c'est une exception je le renvoie en ne faisant pas le reste, sinon je fais le reste ( j'utilise à fond que dans un if then else, seul une des deux closes est exécuté).
Ensuite pour le try, je réutilise allégrement la fonction de matching.

Ce qui marche mal : le fait de faire let f (x, y) = ... in ... mais on sait pas si c'est grave vu qu'à priori on ne considère que des fonctions curryfiées. Ensuite, l'application à une fonction d'une liste sans parenthèses autour ( e.g. f [1] ne sera pas parsé, f ([1]) le sera quant à lui ). Ca, c'est juste parce que on est nul ( la personne qui écrit dit on par mansuétude ). Ensuite, une erreur ne sera renvoyé en cas de doublons dans un matching que si on teste ce matching et qu'il correspond.
Dans le matching d'un try, on autorise à apparaître des choses comme E (a,b) mais de toute facon elle sera pas matché.
Un des tests de bases de l'autotesteur mais qui selon moi (Emile) ne doit pas marcher en Caml donc je me refuse à le faire marcher.
 
