Bon en ce qui concerne le rendu de la partie 1 il n'y a pas grand chose à dire, à ceci près que il n'y a pas les fichiers qui correspondent parfaitement puisque on les a modifié pour faire le rendu de la partie 2.

En ce qui concerne la partie 2, on a rajouté au type cellules, la liste des prédépendances de la cellule, c'est-à-dire, la liste de toutes les autres cellules qui dépendent au premier ordre de la première. ( Autrement dit, la liste des prédépendances d'une cellule A1 est la liste des cellules dont A1 apparaissent dans leur formule ).
Ainsi, quand on change la formule de A1 par exemple, il suffit de supprimer A1 de toutes les listes de prédépendances de toutes les cellules ( puisque on ne devra plus forcément changer A1 quand on aura changer une autre cellule ), puis ensuite on parcourt la nouvelle formule de A1, pour ajouter A1 à la liste des prédépendances. Pour cela, on parcourt la formule, et on crée une ste ou on ajoute que les cases que l'on a pas encore mis ( pour éviter des doublons ), puis on ajoute A1 à la liste des prédépendances de tous les éléments de la liste des dépendances de A1.
Ensuite il reste à recalculer la grille. Pour cela, on fait l'équivalent d'un parcours de graphe, où la liste des sommets adjacents serait la liste des prédépendances, et où chaque fois qu'on passe sur un sommet on le met à None. Ainsi, tous les sommets qui doivent être recalculés sont passés à None et il suffit après de faire le calcul comme à la partie 1 ( on remarque que une cellule pas à None ne sera pas recalculé, ce qui était ce qu'on voulait ).
Pour savoir si il y a une boucle, il suffit de regarder si quand on change la formule de la case x, quand on veut mettre à None tous les éléments que l'on doit recalculer, si à un moment on retombe sur x. En effet, si il n'y avait pas de boucles avant, si on a rajouter une boucle, elle contient forcément x, et donc par notre parcours, si on a rajouter une boucle on va forcément retomber sur x. Si on ne retombe pas sur x c'est qu'on a pas rajouter de boucle.

Si il n'y a pas de boucle, il n'y a qu'à recalculer la grille comme dans la partie 1, si il y en a, si on avait mis l'option paf, il faut soulève une exception, sinon on remet l'ancienne formule, on rechange les prédépedances, puis on recalcule la grille ( on recalculera des choses en trop car il y avait pas besoin de les recalculer mais bon, ce cas n'est pas censé arriver trop souvent donc c'est pas grave.

Enfin pour implémenter l'option -paf sur l'exécutable, on y ait allé un peu au hasard et c'est passé.

Pour la partie 3, on a modifé le type number pour qu'il soit un type somme contenant soit un entier ou soit un float. Et on a aussi modifé les fonctions pour qu'elles manipulent des numbers et non des floats. (On a aussi du modifié le fichier parser.mly pour qu'il transforme les constantes en numbers)

Ensuite, pour rajouter les intervalles, on a juste rajouter les intervalles au type de formule, les intervalles étant codés par un couple de couple d'entiers. ( on a aussi rajouter ':' au caractère que repère Ocaml ). Ensuite pour gérer les intervalles, on a traiter le problème dès le début, à savoir que quand on récupère la formule, directement, si on a un intervalle, on le remplace par toutes les cases qu'il représente. La seule astuce, c'est comme on remplace un intervalle par une liste de cellules, pour que tous soit compatible, on remplace chaque formule par la liste qui contient la formule, et si on a une liste de formules, on a juste à les fusionner. Cela permet aussi ( car en sortie il faut prendre la tête ), de gérer le cas où on écrirait A1 = A2::A5, qui n'a aucun sens, mais qui serait alors remplacer par A1 = A2. De plus, Si on écrit A1 = A2::B3, on va ajouter tout le carré des cases entre A2 et B3.

Pour pouvoir changer de fiche, on crée un tableau qui contient les différentes fiches et une réference globale qui va servir a determiner dans quelle fiche on est ( attention, quand on initialisera toutes les fiches, on fera en sorte que les fiches ne soient pas les mêmes ( le Array.make nb_table (Array.make_Matrix ...) crée un tableau qui contient la même fiches, modifié l'un modifiera les autres )). Et après, il suffit de rajouter partout où il y avait des ShowAll, des SwitchTo ( il y a des variations suivant l'endroit mais l'idée est là ), et dire que quand on tombe dessus, on pense à changer la valeur de la référence globale.
